#ifndef __JBC_DEF_H__
#define __JBC_DEF_H__

#include <stdarg.h>
#include <linux/config.h>
#include "rtk_voip.h"

/* It is an *INTERNAL* file for JBC module, so it used by jbc.c or jbc2.c only. */


#define _NEW_JBC	/* remove old unused code */

/* ================================================================== */
/* JBC Configuration Definition */
/* ================================================================== */

#ifdef SUPPORT_IDEAL_MODE_JITTER_DELAY
 #define SUPPORT_JBC_START_IN_IDEAL_MODE	/* In IDEAL mode instead of NORMAL mode. */
#endif

#define SUPPORT_SPIKE_MODE_WAIT_SKIP	/* In spike mode, wait for skip packet (only for large jitter such as 50) */
										/* Now, it is adopted if out of order packets are exist. */
										/* Actually, it helps 'delay start' to move to target delay. */

#define SUPPORT_CUSTOMIZE_JITTER_DELAY	/* user set (min, max) to (NormalTarget, SpikeMax) */

#define SUPPORT_OPTIMIZATION_FACTOR		/* optimization factor is similar to one of AudioCodes */

/* definition generated by configuration */
/* We DONOT suggest to comment following defined flags. */
#ifdef SUPPORT_OPTIMIZATION_FACTOR
 #ifdef SUPPORT_IDEAL_MODE_JITTER_DELAY
  #define SUPPORT_FACTOR_OF_IDEAL_MODE			/* ideal mode */
  #define SUPPORT_IDEAL_MODE_MINIMIZE_DELAY		/* keep j_len to be 1.x, so compress will be more frequently. */
 #endif
 #ifdef SUPPORT_JBC_START_IN_IDEAL_MODE
  #define SUPPORT_FACTOR_OF_START_IN_IDEAL		/* start in ideal mode */
  /* we assume that SUPPORT_CUSTOMIZE_JITTER_DELAY is also defined. */
  #ifndef SUPPORT_CUSTOMIZE_JITTER_DELAY
   #error "Not define SUPPORT_CUSTOMIZE_JITTER_DELAY causes an unexpected result. "
  #endif
  #define SUPPORT_FACTOR_OF_EARLY_DETECT_COM	/* compression early detect */
  #define SUPPORT_FACTOR_OF_EARLY_DETECT_EXP	/* expansion early detect */
 #endif
#endif

/* optmization factor for function switch */
#define FACTOR_THRES_IDEAL_MODE			3	/* ideal mode: 1 ~ 3 */
#define FACTOR_THRES_START_IN_IDEAL		1	/* start in ideal mode: 1 ~ 1 */
#define FACTOR_THRES_EARLY_DETECT_COM	6	/* early detect compress: 1 ~ 6 */
#define FACTOR_THRES_EARLY_DETECT_EXP	8	/* early detect expand: 8 ~ 12 */
#define FACTOR_THRES_NORMAL_UPPER_BOUND	12	/* optimization factor: 1 ~ 12 */

#define ERALY_DETECT_EXPANSION_JLEN_THRES	2


/* ================================================================== */
/* structure definition */
/* ================================================================== */

#ifdef SUPPORT_ADJUST_JITTER
 #ifdef SUPPORT_DYNAMIC_JITTER_DELAY
  #ifdef SUPPORT_IDEAL_MODE_JITTER_DELAY
	#define NUM_JITTER_DELAY_IDEAL	1
	#define EST_IDEAL_HISTORY_SIZE	10	/* 10 history */
	#define EST_IDEAL_HISTORY_UNIT	100	/* each history contain 100 times of jiiter size */
  #else
  	#define NUM_JITTER_DELAY_IDEAL	0
  #endif
  
 	/* associated with jbc_dynamic_delay[].mode */
 	#define JITTER_DELAY_NORMAL		0
	#define JITTER_DELAY_SPIKE		1
  #ifdef SUPPORT_IDEAL_MODE_JITTER_DELAY
	#define JITTER_DELAY_IDEAL		2
  #endif
	#define NUM_OF_JITTER_DELAY		( 2 + NUM_JITTER_DELAY_IDEAL )
		
	typedef struct jbc_delay_thres_s {	/* map to jbc_xxx_delay[] */
 		int	max;
 		int	min;
 		int	target;
 	} jbc_delay_thres_t;
 	
 	typedef struct est_ideal_mode_s {
 		/* control */
 		uint32				bEnable;
 		/* threshold to switch */
 		uint32				ffDiffThres;	/* threshold of diff to switch */
 		//uint32				ffDiffSoftThres;	/* threshold of diff to slight correction */
 		/* history */
  		uint32				ffHistAvg[ EST_IDEAL_HISTORY_SIZE ];	/* fixed float point */
  		uint32				ffHistDiff[ EST_IDEAL_HISTORY_SIZE ];
  		uint32				nHistWi;
  		uint32				bHistReady;			/* All of 10 histories are valid? */
  		/* last record in history */
  		uint32				ffLastHistAvg;	/* read it only if bHistReady */
  		/* each 100 jitter length */
  		uint32				nCurJLen[ EST_IDEAL_HISTORY_UNIT ];
  		uint32				nCurWi;
  		/* switch to ideal mode */
  		uint32				bCanTryCompress;	/* each history list can try compress once. */
  		uint32				nTryCompress;
		/* compress to be minimized delay */
  #ifdef SUPPORT_IDEAL_MODE_MINIMIZE_DELAY
		uint32 				bIdealModeCompress;
  		uint32				ffDiffThresIdealCompress;	/* ideal mode compress to get minimized delay */
  #endif
 	} est_ideal_mode_t;
 	
 	typedef struct wait_skip_s {
 		uint16				nSpikeWaitSeqNum;		/* WAIT_SLOW expected seq number */
  		uint16				nSpikeWaitCount;		/* do WAIT_SOLW count */
  		uint16				bExistLastOutOfOrder;	/* out-of-order packet detected */
  		uint32				dStatLastOutOfOrder;	/* TTL of above flag */
 	} wait_skip_t;
 	
 	typedef struct customize_delay_s {
 		uint32				nMinDelay;	/* for target of normal mode */
 		uint32				nMaxDelay;	/* for max of spike mode */
 	} customize_delay_t;
 	
 	typedef struct optimize_factor_s {
 		uint32				nFactor;	/* optimization factor (We don't see this value at most time) */
 		/* factor will turn on/off some functions: */
  #ifdef SUPPORT_FACTOR_OF_EARLY_DETECT_COM
 		uint32				bEarlyDetectCompress;
 		uint32				ffDiffThresCompress;	/* threshold of diff to compress */
 		uint32				ff13FastRatio;			/* fast ratio (2^13) */
  #endif
  #ifdef SUPPORT_FACTOR_OF_EARLY_DETECT_EXP
 		uint32				bEarlyDetectExpand;
 		int					nJitterLenLowThres;
 		uint32				ffDiffThresExpand;	/* threshold of diff to expand */
  #endif
  		/* threshold for old design facilities */
  		uint32				nSwitchWaitCntThres;	/* Switch mode from spike to normal, if count of ( j_len < normal.max ) larger than this value. */
 	} optimize_factor_t;

	typedef struct jbc_dynamic_var_s {
	 	jbc_delay_thres_t	delay_thres[ NUM_OF_JITTER_DELAY ];
	 	uint8	/* S */		mode;				/* 'S' indicates the variable set by SetDelayModeOfJBC() */
	 	int					nPrevJitterLen;
	 	uint32	/* S */		nStableSum;	
	 	uint32	/* S */		nStableSumCnt;
	 	uint16	/* S */		nStableWaitCnt;	
	 	uint8	/* S */		nSwitchWaitCnt;		/* packet debouncing */
	 	uint8	/* S */		bSwitch2Normal;	
	 	uint8	/* S */		bDisableMinDelay;	/* assist early compress detect */
	 	uint16	/* S */		nEFWaitCnt;			/* assist early compress detect */
  #ifdef SUPPORT_IDEAL_MODE_JITTER_DELAY
  		est_ideal_mode_t	est_ideal;
  #endif
  #ifdef SUPPORT_SPIKE_MODE_WAIT_SKIP
  		wait_skip_t			wait_skip;
  #endif
  #ifdef SUPPORT_CUSTOMIZE_JITTER_DELAY
  		customize_delay_t	customize_delay;
  #endif
  #ifdef SUPPORT_OPTIMIZATION_FACTOR
		optimize_factor_t	factor;
  #endif
	} jbc_dynamic_var_t;
	
	extern jbc_dynamic_var_t jbc_dynamic_delay[ MAX_SESS_NUM ];
 #endif /* SUPPORT_DYNAMIC_JITTER_DELAY */
#endif /* SUPPORT_ADJUST_JITTER */

#define PLAYOUT_L3_AVG_ORDER	4
#define PLAYOUT_L3_AVG_NUM		( 1UL << PLAYOUT_L3_AVG_ORDER )
#define PLAYOUT_L2_AVG_ORDER	3
#define PLAYOUT_L2_AVG_NUM		( 1UL << PLAYOUT_L2_AVG_ORDER )
#define PLAYOUT_LOCAL_ORDER		8
#define PLAYOUT_LOCAL_COUNT		( 1UL << PLAYOUT_LOCAL_ORDER )

typedef struct {	/* in unit of 1ms */
	uint32					nGlobalAvg;
	uint32					nL3Avg[ PLAYOUT_L3_AVG_NUM ];
	uint32					nL3Count;
	uint32					nL2Avg[ PLAYOUT_L2_AVG_NUM ];
	uint32					nL2Count;
	uint32					nLocalSum;
	uint32					nLocalCount;
} playout_histogram_t;

#define STATIS_HISTORY_NUM		4
#define STATIS_HISTORY_DEFER	5

typedef struct {
	uint32					nCompression;
	uint32					nCompression_history[ STATIS_HISTORY_NUM ];
	uint32					nExpansion;
	uint32					nExpansion_history[ STATIS_HISTORY_NUM ];
	uint32					nLendPLC;	// borrow to save 
	uint32					nLendPLC_history[ STATIS_HISTORY_NUM ];
	uint32					nDeferSample_history;
} wsola_statistics_t;

typedef struct {
	uint32					nLastJitterLen;
	playout_histogram_t		playout;
	wsola_statistics_t		wsola;
	uint32					nSilenceSpeech;
	uint32					nDiscardFrames;
} jbc_statistics_var_t;	/* we use memset to initialize this variable. */

extern jbc_statistics_var_t jbc_statistics[ MAX_SESS_NUM ];

/* ================================================================== */
/* internal variables definition */
/* ================================================================== */

extern unsigned short  R1_decSeqNum[MAX_SESS_NUM];			/* expected seq # */
extern Flag playOutStart[MAX_SESS_NUM];                    // flag to start playout
extern Word16  jBufPtr[MAX_SESS_NUM];                              // read pointer of jitterBuf (R1 read)
extern Word16  wait_cnt[MAX_SESS_NUM];                             // % wait the not_arrived packet

extern enum    AP_MODE task[MAX_SESS_NUM];
extern Word16  jbc_pStatus[MAX_SESS_NUM];                                  //% current packet arrival status
extern Word16  jbc_p2Status[MAX_SESS_NUM];                         //% next packet arrival status
extern Flag    pVoiceSID[MAX_SESS_NUM];                            //% current packet voice/SID status
extern Flag    p2VoiceSID[MAX_SESS_NUM];                           // next packet voice/SID status

extern Word16  FastRatio[MAX_SESS_NUM];                     // 0.8568 @ Q13

extern Word16  Pkt1_ri[MAX_SESS_NUM];                          
extern Word16  Pkt2_ri[MAX_SESS_NUM];

extern int jbc_max_delay[MAX_SESS_NUM];
extern int jbc_min_delay[MAX_SESS_NUM];
extern int jbc_target_delay[MAX_SESS_NUM];
extern int jbc_start_delay[MAX_SESS_NUM];

extern Word16  mindelay_wait_cnt[MAX_SESS_NUM];
extern Word16  adjust_target_delay[MAX_SESS_NUM];  /* If j_len < min_delay[] */
extern Word16  adjust_max_delay[MAX_SESS_NUM];             /* If j_len > max_delay[] */
extern Word16  maxdelay_wait_cnt[MAX_SESS_NUM];

extern int jbc_disable_wsola[MAX_SESS_NUM];

#define pSend	RECV_ADDR
#define pRecv	SEND_ADDR

/* ================================================================== */
/* internal function prototype */
/* ================================================================== */

/* fnJitterBufControl_xxx series function */
extern void fnJitterBufControl_DisableWsola(uint32 ssid, Word16 *ri, Word16 ownFlag);
extern int fnJitterBufControl_DetectMaxDelay( uint32 ssid, Word16 *ri, int j_len, jbc_dynamic_var_t * pNowJbcDyanmicVar );
extern int fnJitterBufControl_DetectMinDelay( uint32 ssid, Word16 *slow_ratio, int j_len, jbc_dynamic_var_t * pNowJbcDyanmicVar );

/* __Final__TaskXxx series function */
extern void __Final__TaskDecPlayFast( uint32 ssid, Word16 *ri );
extern void __Final__TaskDecPlaySlow( uint32 ssid, Word16 *ri, Word16 *slow_ratio );
extern void __Final__TaskDecNormal( uint32 ssid, Word16 *ri );

/* NormalArriveProc_xxx series function */
extern int NormalArriveProc_SpikeMode( uint32 ssid, int j_len, jbc_dynamic_var_t * pNowJbcDyanmicVar );
extern int NormalArriveProc_NormalMode( uint32 ssid, Word16 *ri, Word16 *fast_ratio, Word16 *slow_ratio, int j_len, jbc_dynamic_var_t * pNowJbcDyanmicVar );
extern int NormalArriveProc_IdealMode( uint32 ssid, Word16 *ri, Word16 *fast_ratio, int j_len, jbc_dynamic_var_t * pNowJbcDyanmicVar );

/* comparison function */
extern bool RtpSeqNumGreater(uint16 a, uint16 b);
extern bool RtpTimeStampGreater(uint32 a, uint32 b);

/* length of jitter buffer */
extern int jitbuf_len( uint32 ssid, Word16 ri );

/* JBC mode */
extern void SetDelayModeOfJBC( uint32 ssid, uint8 mode );

/* EstIdealMode_xxx series function */
extern int EstIdealMode_CheckStableHistory( uint32 ssid, uint32 *pffMaxDiff, uint32 *pffTotalAvg );
extern int EstIdealMode_GetMaxDiffAndTotalAvg( uint32 ssid, uint32 *pffMaxDiff, uint32 *pffTotalAvg );

/* JbcStatistics_xxx series function */
extern void JbcStatistics_JitterLength( uint32 ssid, uint32 len );
extern void JbcStatistics_PlayoutDelay( uint32 ssid, uint32 arrive );
extern void JbcStatistics_WsolaCompression( uint32 ssid );
extern void JbcStatistics_WsolaExpansion( uint32 ssid );
extern void JbcStatistics_WsolaLendPLC( uint32 ssid );
extern void JbcStatistics_SilenceSpeech( uint32 ssid );

/* ================================================================== */
/* internal inline function */
/* ================================================================== */
#ifdef SUPPORT_IDEAL_MODE_JITTER_DELAY
static inline uint32 ffFromN( uint32 n )
{
	/* convert normal number to fixed float point */
	return ( n << 10 );
}

static inline uint32 nFromFf( uint32 ff )
{
	/* convert fixed float point to normal number */
	return ( ff >> 10 );
}
#endif

/* ================================================================== */
/* constant definition */
/* ================================================================== */

#define MAX_RI			(Word16)(BUFFER_NUM_DEC-1)
//#define DELAY_DEPTH	    1000		// delay distribution dpeth

// pkt types
#define VOICE_PKT		0
#define SID_PKT			1

// historial buffer 
//#define W0				4*32		// % histogram depth 
//#define Q0				(W0-0)
//#define Q1				(W0-1)

// traffic modes
#define NORMAL			0
#define SPIKE			1
#define CNG_MODE		2

/* ================================================================== */
/* debug message macro */
/* ================================================================== */

//#define _SESSION_DEBUG	/* debug specific session */

#ifdef _SESSION_DEBUG
#define set_printk_x( x )	{ printk_x = x; }
extern uint32 printk_x;

static inline void printk_x_core( uint32 sid, const char *format, va_list args )
{
	unsigned char buffer[ 256 ];
	
	if( printk_x == sid ) {
		vsprintf( buffer, format, args );
		printk( buffer );
	}
}

static inline void printk_0( const char *format, ... )	/* print if ssid == 0 */
{
	va_list args;
	
	va_start( args, format );
	
	printk_x_core( 0 /* sid */, format, args );
}

static inline void printk_1( const char *format, ... )	/* print if ssid == 1 */
{
	va_list args;
	
	va_start( args, format );
	
	printk_x_core( 1 /* sid */, format, args );
}
#else
#define set_printk_x( x )
#endif // 1

static inline void printk_off( const char *format, ... ) {}
static inline void printk_0( const char *format, ... ) {}	/* print if ssid == 0 */
static inline void printk_1( const char *format, ... ) {}	/* print if ssid == 1 */

#define debug_jbc	printk_off	// debug purpose
#define debug_dj	printk_off	// debug dynamic jitter
#define debug_dj2	printk_off	// debug dynamic jitter (early detect)
#define debug_im	printk_off	// debug ideal mode 
#define debug_plc	printk_off	// debug plc, sKip or Loss 
#define debug_opt	printk_off	// debug optimize factor 

#endif /* __JBC_DEF_H__ */

